# GTU-C312 OS Code
# ==================

Begin Data Section
    # CPU Registers (conceptual, already defined by CPU spec)
    # 0 0 # PC
    # 1 0 # SP
    # 2 0 # Syscall Result/Param (OS uses this for syscall type)
    # 3 0 # Instructions Executed by CPU

    # OS Global Variables
    4 0   # MEM_OS_CURRENT_THREAD_ID (0 for OS, 1-10 for user)
    5 1   # MEM_OS_NEXT_SCHEDULE_ID (starts with thread 1)
    6 3   # MEM_OS_MAX_USER_THREADS (Project requires at least 3 threads)
    7 6   # MEM_OS_THREAD_ENTRY_SIZE (PC, SP, State, StartTime, ExecsUsed, BlockUntil)
    8 50  # MEM_OS_THREAD_TABLE_BASE (TCBs start here)
    9 0   # MEM_OS_TEMP_A (General purpose temp)
    10 0  # MEM_OS_TEMP_B
    11 0  # MEM_OS_TEMP_C
    12 0  # MEM_OS_STATE_READY_VAL
    13 1  # MEM_OS_STATE_RUNNING_VAL
    14 2  # MEM_OS_STATE_BLOCKED_VAL
    15 3  # MEM_OS_STATE_TERMINATED_VAL
    16 4  # MEM_OS_STATE_INACTIVE_VAL
    17 100 # MEM_OS_SYSCALL_BLOCK_DURATION (for PRN)
    18 199 # OS_STACK_POINTER_INITIAL_VAL (OS stack grows down from just before OS code, e.g. 199)
    19 0   # OS_TEMP_D (another temp, for loop counters etc)
    20 0   # OS_TEMP_E (another temp, for addresses)
    21 0   # OS_SYSCALL_ARG_A (For PRN A, CPU puts A here)
    # Syscall type codes (placed in mem[2] by CPU simulator)
    # 22 0 # SYSCALL_TYPE_YIELD_CODE
    # 23 1 # SYSCALL_TYPE_HLT_CODE
    # 24 2 # SYSCALL_TYPE_PRN_CODE
    # TCB Offsets from TCB base
    25 0 # TCB_OFFSET_PC
    26 1 # TCB_OFFSET_SP
    27 2 # TCB_OFFSET_STATE
    28 3 # TCB_OFFSET_START_TIME
    29 4 # TCB_OFFSET_EXECS_USED
    30 5 # TCB_OFFSET_BLOCK_UNTIL


    # Thread Table (TCBs)
    # TCB for OS (Thread 0) - Fields: PC, SP, State, StartTime, ExecsUsed, BlockUntil
    # Addresses: 50=PC, 51=SP, 52=State, 53=StartTime, 54=ExecsUsed, 55=BlockUntil
    50 200 # OS_TCB_PC (OS_BOOT_START_ADDR)
    51 199 # OS_TCB_SP (Initial OS Stack Pointer)
    52 1   # OS_TCB_State (RUNNING)
    53 0   # OS_TCB_StartTime
    54 0   # OS_TCB_ExecsUsed
    55 0   # OS_TCB_BlockUntil

    # TCB for Thread 1 (User Thread)
    # Addresses: 56=PC, 57=SP, 58=State, 59=StartTime, 60=ExecsUsed, 61=BlockUntil
    56 1000 # T1_TCB_PC
    57 1999 # T1_TCB_SP
    58 4    # T1_TCB_State (INACTIVE initially)
    59 0    # T1_TCB_StartTime
    60 0    # T1_TCB_ExecsUsed
    61 0    # T1_TCB_BlockUntil

    # TCB for Thread 2 (User Thread)
    # Addresses: 62=PC, 63=SP, 64=State, 65=StartTime, 66=ExecsUsed, 67=BlockUntil
    62 2000 # T2_TCB_PC
    63 2999 # T2_TCB_SP
    64 4    # T2_TCB_State (INACTIVE initially)
    65 0    # T2_TCB_StartTime
    66 0    # T2_TCB_ExecsUsed
    67 0    # T2_TCB_BlockUntil

    # TCB for Thread 3 (User Thread)
    # Addresses: 68=PC, 69=SP, 70=State, 71=StartTime, 72=ExecsUsed, 73=BlockUntil
    68 3000 # T3_TCB_PC
    69 3999 # T3_TCB_SP
    70 4    # T3_TCB_State (INACTIVE initially)
    71 0    # T3_TCB_StartTime
    72 0    # T3_TCB_ExecsUsed
    73 0    # T3_TCB_BlockUntil

    # ... Up to 10 user threads. For brevity, only 3 shown for full TCB init.
    # For example, TCB for Thread 4 starts at 74.
    74 0    # T4_TCB_PC
    75 0    # T4_TCB_SP
    76 4    # T4_TCB_State (INACTIVE)
    77 0    # ... and so on for other TCB fields if Thread 4 exists

    # Initial PC for OS Boot Code (mem[0]) must point to the first OS instruction.
    0 200 # OS_BOOT_START_ADDR
End Data Section

Begin Instruction Section
# ==============================
# OS Boot and Initialization (OS_BOOT_START_ADDR)
# ==============================
200 CPY 18 1           # Set OS Stack Pointer (mem[1]) from MEM_OS_STACK_POINTER_INITIAL_VAL (mem[18])
201 SET 220 50         # OS_TCB[0].PC (mem[50]) = HANDLE_SYSCALL_ENTRY_ADDR (220)
202 CPY 1 51           # OS_TCB[0].SP (mem[51]) = current OS SP (mem[1])
203 CPY 13 9           # TEMP_A (mem[9]) = STATE_RUNNING_VAL (mem[13])
204 SET 9 52           # OS_TCB[0].State (mem[52]) = content of TEMP_A (mem[9])
205 CPY 3 53           # OS_TCB[0].StartTime (mem[53]) = current CPU exec count (mem[3])
206 SET 0 54           # OS_TCB[0].ExecsUsed (mem[54]) = 0
207 SET 0 55           # OS_TCB[0].BlockUntil (mem[55]) = 0

    # Initialize User Thread TCBs (Mark them as READY)
208 CPY 12 9           # TEMP_A (mem[9]) = STATE_READY_VAL (mem[12])
209 SET 9 58           # TCB[1].State (mem[58]) = content of TEMP_A (mem[9])
210 SET 9 64           # TCB[2].State (mem[64]) = content of TEMP_A (mem[9])
211 SET 9 70           # TCB[3].State (mem[70]) = content of TEMP_A (mem[9])
    # PCs and SPs for T1, T2, T3 are already set in Data Section.

    # Set current thread to OS (0) and next to schedule to Thread 1
212 SET 0 4            # MEM_OS_CURRENT_THREAD_ID (mem[4]) = 0 (OS itself)
213 SET 1 5            # MEM_OS_NEXT_SCHEDULE_ID (mem[5]) = 1

    # Jump to Scheduler (SCHEDULER_START_ADDR defined as line 300)
214 SET 300 0          # PC (mem[0]) = 300

# ==============================
# SYSCALL Handler Entry Point (HANDLE_SYSCALL_ENTRY_ADDR)
# CPU simulator should:
# 1. Switch to Kernel mode.
# 2. Save user PC (instruction *after* SYSCALL) into mem[0].
# 3. Save user SP into mem[1].
# 4. Put syscall type code in mem[2] (e.g., 0 for YIELD, 1 for HLT, 2 for PRN).
# 5. Put syscall argument (e.g., address for PRN for SYSCALL PRN A) in mem[21] (OS_SYSCALL_ARG_A).
# 6. Set OS PC (mem[0]) to HANDLE_SYSCALL_ENTRY_ADDR (this block, e.g., 220).
# 7. Set OS SP (mem[1]) to OS stack pointer (value from mem[18] or mem[51]).
# ==============================
220 CPY 18 1           # Ensure OS Stack Pointer is set
221 CPY 4 9            # TEMP_A (mem[9]) = MEM_OS_CURRENT_THREAD_ID (the thread that called syscall)

    # --- Unrolled Save Context & Handle Syscall based on Thread ID ---
    # IF Current Thread ID == 1
222 SET 1 10           # TEMP_B (mem[10]) = 1
223 CPY 9 11           # TEMP_C (mem[11]) = current_thread_id (from TEMP_A)
224 SUBI 10 11         # TEMP_C = current_thread_id - 1
225 JIF 11 228         # If current_thread_id <= 1
226 CPY 10 11          # TEMP_C (mem[11]) = 1
227 SUBI 9 11          # TEMP_C = 1 - current_thread_id
228 JIF 11 230         # If 1 <= current_thread_id (Combined: current_thread_id == 1)
                       # If not 1, JIF fails, fall through to next ID check (at line 240)
    # Handle Syscall for Thread 1 (TCB at 56-61)
229 CPY 0 56           # TCB[1].PC (mem[56]) = Saved User PC (from mem[0])
230 CPY 1 57           # TCB[1].SP (mem[57]) = Saved User SP (from mem[1])
    # Check syscall type from mem[2]
231 CPY 2 10           # TEMP_B (mem[10]) = syscall_type
    # if type == YIELD (assume YIELD code = 0, HLT code = 1, PRN code = 2)
232 JIF 10 234         # If type <= 0 (is YIELD)
233 CPY 12 9           # TEMP_A (mem[9]) = STATE_READY_VAL (mem[12])
234 SET 9 58           # TCB[1].State (mem[58]) = READY
235 SET 300 0          # Jump to Scheduler (300)
    # if type == HLT (1)
236 SET 1 11           # TEMP_C (mem[11]) = 1 (HLT code)
237 CPY 10 9           # TEMP_A (mem[9]) = syscall_type
238 SUBI 11 9          # TEMP_A = type - 1
239 JIF 9 242          # If type - 1 <= 0 (type <= 1)
240 CPY 11 9           # TEMP_A (mem[9]) = 1
241 SUBI 10 9          # TEMP_A = 1 - type
242 JIF 9 244          # If 1 - type <= 0 (type == 1) (HLT)
243 CPY 15 9           # TEMP_A (mem[9]) = STATE_TERMINATED_VAL (mem[15])
244 SET 9 58           # TCB[1].State (mem[58]) = TERMINATED
245 SET 300 0          # Jump to Scheduler (300)
    # if type == PRN (2)
246 SET 2 11           # TEMP_C (mem[11]) = 2 (PRN code)
    # (equality check for 2 for PRN type - similar to HLT)
    # Assuming it matched PRN:
247 CPY 14 9           # TEMP_A (mem[9]) = STATE_BLOCKED_VAL (mem[14])
248 SET 9 58           # TCB[1].State (mem[58]) = BLOCKED
249 CPY 3 10           # TEMP_B (mem[10]) = current CPU exec count (mem[3])
250 ADDI 17 10         # TEMP_B += MEM_OS_SYSCALL_BLOCK_DURATION (mem[17])
251 SET 10 61          # TCB[1].BlockUntil (mem[61]) = TEMP_B
252 SET 300 0          # Jump to Scheduler (300)

    # IF Current Thread ID == 2 (Instruction line after Thread 1's HLT JIF or fallthrough)
    # Similar block as above for Thread 1, starting at (e.g.) 253
    # This checks if TEMP_A (original current_thread_id) is 2
253 CPY 4 9            # Reload current_thread_id into TEMP_A (mem[9]) (Might have been overwritten by syscall type logic)
254 SET 2 10           # TEMP_B (mem[10]) = 2
    # ... (equality check: if TEMP_A == 2) ... jump to T2 handler or fall through
    # Handler for Thread 2 (TCB at 62-67) - Save PC/SP, update state, jump to scheduler.
    # ...

    # IF Current Thread ID == 3
    # ... (similar block for Thread 3, TCB at 68-73) ...

    # Fallthrough if no ID matched (error or OS was current thread - though OS doesn't syscall)
299 SET 300 0          # Default: Go to Scheduler

# ==============================
# Scheduler (SCHEDULER_START_ADDR)
# ==============================
300 CPY 18 1           # Ensure OS Stack Pointer is set for OS operations
    # Save OS context to TCB[0] (Optional: only if OS does complex calls/stack usage)
    # SET 300 50         # TCB[0].PC = 300 (current)
    # CPY 1 51           # TCB[0].SP = current SP (mem[1])

    # Find next thread to run
301 CPY 6 19           # TEMP_D (mem[19]) = max_user_threads (e.g., 3 from mem[6])
302 ADD 19 1           # TEMP_D = max_user_threads + 1 (loop limit for outer search)
    # Outer loop: iterate at most MAX_USER_THREADS times to find a runnable thread
303 ADD 19 -1          # Decrement outer loop counter (TEMP_D)
304 CPY 19 9           # Copy TEMP_D to TEMP_A for JIF (JIF uses memory location content)
305 JIF 9 450          # If outer loop counter (mem[9]) <= 0, no thread found -> HLT OS (line 450)

306 CPY 5 9            # TEMP_A (mem[9]) = id_to_check (from MEM_OS_NEXT_SCHEDULE_ID mem[5])

    # --- Check Thread 1 ---
307 SET 1 10           # TEMP_B (mem[10]) = 1 (Thread ID literal for comparison)
308 CPY 9 11           # TEMP_C (mem[11]) = id_to_check (from TEMP_A)
309 SUBI 10 11         # TEMP_C = id_to_check - 1
310 JIF 11 313         # If id_to_check <= 1
311 CPY 10 11          # TEMP_C (mem[11]) = 1
312 SUBI 9 11          # TEMP_C = 1 - id_to_check
313 JIF 11 315         # If 1 <= id_to_check (Combined: id_to_check == 1)
                       # If not 1, JIF fails, fall through to next ID check (line 340 for T2)
    # ID is 1. Current state from TCB[1].State (addr 58)
314 CPY 58 20          # TEMP_E (mem[20]) = TCB[1].State
    # Check if BLOCKED
315 CPY 14 11          # TEMP_C (mem[11]) = STATE_BLOCKED_VAL (mem[14])
316 CPY 20 9           # TEMP_A (mem[9]) = current state (from TEMP_E)
317 SUBI 11 9          # TEMP_A = state - BLOCKED_VAL
318 JIF 9 321          # If state <= BLOCKED_VAL
319 CPY 11 9           # TEMP_A (mem[9]) = BLOCKED_VAL
320 SUBI 20 9          # TEMP_A = BLOCKED_VAL - state
321 JIF 9 323          # If BLOCKED_VAL <= state (Combined: state == BLOCKED)
                       # If not BLOCKED, JIF fails, fall through to READY check (line 329)
    # Thread 1 is BLOCKED. Check if it can be unblocked.
322 CPY 61 10          # TEMP_B (mem[10]) = TCB[1].BlockUntil (mem[61])
323 CPY 3 9            # TEMP_A (mem[9]) = Current CPU Exec Count (mem[3])
    # We need BlockUntil - CurrentExec <= 0 for JIF to pass for unblocking
324 CPY 10 20          # TEMP_E (mem[20]) = BlockUntil
325 SUBI 9 20          # TEMP_E = BlockUntil - CurrentExec (mem[3] has CurrentExec)
326 JIF 20 328         # If (BlockUntil - CurrentExec) <= 0, then time to unblock
                       # If JIF fails, still blocked, skip to next part of scheduler
327 SET 400 0          # JMP to update_next_id_and_loop_scheduler (line 400)
    # Unblock:
328 CPY 12 9           # TEMP_A (mem[9]) = STATE_READY_VAL (mem[12])
329 SET 9 58           # Set TCB[1].State (mem[58]) = READY
330 CPY 12 20          # TEMP_E (mem[20]) = STATE_READY_VAL (updated state for next check)
    # Check if READY (either initially or after unblocking)
331 CPY 12 11          # TEMP_C (mem[11]) = STATE_READY_VAL (mem[12])
332 CPY 20 9           # TEMP_A (mem[9]) = current state (from TEMP_E, possibly updated to READY)
333 SUBI 11 9          # TEMP_A = state - READY_VAL
334 JIF 9 337          # if state <= READY_VAL
335 CPY 11 9           # TEMP_A (mem[9]) = READY_VAL
336 SUBI 20 9          # TEMP_A = READY_VAL - state
337 JIF 9 339          # if READY_VAL <= state (Combined: state == READY)
                       # If not READY, JIF fails, fall through (line 338 -> 400)
    # Thread 1 is READY. Dispatch it.
338 SET 1 4            # MEM_OS_CURRENT_THREAD_ID (mem[4]) = 1
339 SET 2 5            # MEM_OS_NEXT_SCHEDULE_ID (mem[5]) = 2 (hardcoded T1 -> T2)
340 SET 500 0          # JMP to Dispatcher (line 500)

    # --- Check Thread 2 --- (Fallthrough from T1 or explicit jump from T1's JIF failures)
    # Instruction line will be after 340, e.g., 341
341 CPY 5 9            # TEMP_A (mem[9]) = id_to_check (from MEM_OS_NEXT_SCHEDULE_ID mem[5])
342 SET 2 10           # TEMP_B (mem[10]) = 2 (Thread ID literal for comparison)
    # ... (similar logic as Thread 1 for checking ID, state, blocking, readiness)
    # On ready, for Thread 2:
    #   SET 2 4            # MEM_OS_CURRENT_THREAD_ID (mem[4]) = 2
    #   SET 3 5            # MEM_OS_NEXT_SCHEDULE_ID (mem[5]) = 3 (T2 -> T3)
    #   SET 500 0          # JMP to Dispatcher (line 500)
    # If not dispatching T2, jump to (or fall through to) check Thread 3 (e.g. line 370)

    # --- Check Thread 3 --- (Fallthrough or jump)
    # Instruction line e.g., 370
370 CPY 5 9            # TEMP_A (mem[9]) = id_to_check (from MEM_OS_NEXT_SCHEDULE_ID mem[5])
371 SET 3 10           # TEMP_B (mem[10]) = 3 (Thread ID literal for comparison)
    # ... (similar logic as Thread 1 & 2)
    # On ready, for Thread 3:
    #   SET 3 4            # MEM_OS_CURRENT_THREAD_ID (mem[4]) = 3
    #   SET 1 5            # MEM_OS_NEXT_SCHEDULE_ID (mem[5]) = 1 (T3 -> T1 wrap around)
    #   SET 500 0          # JMP to Dispatcher (line 500)
    # If not dispatching T3, jump to (or fall through to) update_next_id (line 400)

    # (Label for jump if a thread is checked but not dispatched, or JIF for ID check fails)
    # This is the target if a specific thread check (T1, T2, or T3) completes
    # without dispatching that thread.
400 CPY 5 9            # TEMP_A (mem[9]) = current MEM_OS_NEXT_SCHEDULE_ID (mem[5])
401 ADD 9 1            # TEMP_A++
402 CPY 6 10           # TEMP_B (mem[10]) = MAX_USER_THREADS (mem[6], e.g. 3)
403 CPY 9 11           # TEMP_C (mem[11]) = TEMP_A (new next_id)
404 SUBI 10 11         # TEMP_C = new_next_id - MAX_USER_THREADS
    # If new_next_id > MAX_USER_THREADS, then (new_next_id - MAX) will be > 0. JIF will fail.
    # e.g. MAX=3. new_id=4. (4-3)=1. JIF fails.
    # e.g. MAX=3. new_id=3. (3-3)=0. JIF passes.
    # e.g. MAX=3. new_id=1. (1-3)=-2. JIF passes.
405 JIF 11 407         # If (new_next_id - MAX_USER_THREADS) <= 0, new_next_id is valid (<= MAX)
                       # If JIF fails, new_next_id was > MAX_USER_THREADS, so wrap around.
406 SET 1 9            # Wrap around: TEMP_A (mem[9]) = 1
407 SET 9 5            # Update MEM_OS_NEXT_SCHEDULE_ID (mem[5]) with TEMP_A (mem[9])
408 SET 303 0          # Loop back to check next thread in scheduler outer loop (line 303)

450 HLT                # Idle/Problem: No thread ready after full scan. Halt OS.

# ==============================
# Dispatcher (DISPATCHER_START_ADDR)
# ==============================
500 CPY 4 9            # TEMP_A (mem[9]) = id_to_run (from MEM_OS_CURRENT_THREAD_ID mem[4])

    # Dispatch Thread 1
501 SET 1 10           # TEMP_B (mem[10]) = 1
502 CPY 9 11           # TEMP_C (mem[11]) = id_to_run (from TEMP_A)
503 SUBI 10 11         # TEMP_C = id_to_run - 1
504 JIF 11 507         # if id_to_run <= 1
505 CPY 10 11          # TEMP_C (mem[11]) = 1
506 SUBI 9 11          # TEMP_C = 1 - id_to_run
507 JIF 11 509         # if id_to_run == 1
                       # If not 1, JIF fails, fall through to T2 dispatch (line 516)
508 CPY 56 0           # PC (mem[0]) = TCB[1].PC (mem[56])
509 CPY 57 1           # SP (mem[1]) = TCB[1].SP (mem[57])
510 CPY 13 10          # TEMP_B (mem[10]) = STATE_RUNNING_VAL (mem[13])
511 SET 10 58          # TCB[1].State (mem[58]) = RUNNING (content of TEMP_B)
512 CPY 3 10           # TEMP_B (mem[10]) = current CPU exec count (mem[3])
513 SET 10 59          # TCB[1].StartTime (mem[59]) = current CPU exec (content of TEMP_B)
514 USER               # Switch to user mode, CPU jumps to PC in mem[0]
515 HLT                # Should not be reached if USER works. Safety halt / OS error.

    # Dispatch Thread 2 (Fallthrough from T1 JIF fail, or explicit jump)
    # Instruction line after 515, e.g. 516
516 SET 2 10           # TEMP_B (mem[10]) = 2
    # ... (similar equality check for id_to_run == 2) ...
    # If id_to_run == 2:
    #   CPY 62 0           # PC = TCB[2].PC (mem[62])
    #   CPY 63 1           # SP = TCB[2].SP (mem[63])
    #   CPY 13 10; SET 10 64 # TCB[2].State = RUNNING
    #   CPY 3 10; SET 10 65  # TCB[2].StartTime = current CPU exec
    #   USER
    #   HLT
    # If not 2, fall through to T3 dispatch (e.g. line 530)

    # Dispatch Thread 3 (Fallthrough from T2 JIF fail, or explicit jump)
    # Instruction line after T2 block, e.g. 530
530 SET 3 10           # TEMP_B (mem[10]) = 3
    # ... (similar equality check for id_to_run == 3) ...
    # If id_to_run == 3:
    #   CPY 68 0           # PC = TCB[3].PC (mem[68])
    #   CPY 69 1           # SP = TCB[3].SP (mem[69])
    #   CPY 13 10; SET 10 70 # TCB[3].State = RUNNING
    #   CPY 3 10; SET 10 71  # TCB[3].StartTime = current CPU exec
    #   USER
    #   HLT

    # Fallthrough if ID not found in dispatcher (Error case)
550 SET 300 0          # Error: ID not found in dispatcher, go back to scheduler (line 300)

End Instruction Section